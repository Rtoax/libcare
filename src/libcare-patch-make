#!/bin/sh -e

usage() {
cat<<'EOF'
Makes `kpatch'es for the makesystem in the current directory.

Usage:	libcare-patch-make [-h|--help] [-u|--update || -c|--clean]
	[-s|--srcdir=SRCDIR] \
	[-d|--destdir=DESTDIRVAR] \
	[-j|--jobs=<number of jobs>] \
	PATCH1 PATCH2 ...

Run from inside the directory with `make'ble software. Makesystem must support
install with specified DESTDIR.

  -c --clean	do a clean build, execute `make clean` first
  -u --update	only update existing patches without rebuild. useful when
		working on patch utils.
  -s --srcdir	
  -d --destdir	specify variable makefile system uses to specify destination
		directory for the installation
  -j --jobs		specify variable makefile system jobs of compile, like `make -j 4`
		is startup `4` jobs to compile.
EOF
		exit ${1-0}
}

function press_any_key()
{
	echo -e "\033[1;31m>>>> $1 <<<<\033[m"
	read -r -p "Press any key to continue..." __input
}

prepare_env() {
	KPATCH_PATH=$(dirname $0)

	if test ! -x "$KPATCH_PATH/kpatch_gensrc"; then
		echo "kpatch tools are missing" >&2
		exit 1
	fi

	press_any_key "Change CC to $KPATCH_PATH/libcare-cc"
	# 修改编译器到 libcare 库
	export IS_LIBCARE_CC=y
	export CC=$KPATCH_PATH/libcare-cc
	export CXX=$CC
	
	# 修改 CC 到 libcare-cc
	# 这种方法不行
	# sed 's/CC=cc/CC=libcare-cc/g' -i build/config-host.mak

	MAKE_OUTPUT=/dev/stdout

	LPMAKEFILE=""
	test -f lpmakefile && LPMAKEFILE="-f lpmakefile"

	LPMAKE_ORIGINAL_DIR="${LPMAKE_ORIGINAL_DIR-$PWD/lpmake}"
	LPMAKE_PATCHED_DIR="${LPMAKE_PATCHED_DIR-$PWD/.lpmaketmp/patched}"
	LPMAKE_PATCHROOT="${LPMAKE_PATCHROOT-$PWD/patchroot}"

	export LPMAKE_ORIGINAL_DIR LPMAKE_PATCHED_DIR LPMAKE_PATCHROOT
	mkdir -p "$LPMAKE_ORIGINAL_DIR" "$LPMAKE_PATCHED_DIR" "$LPMAKE_PATCHROOT"

	unset MAKELEVEL
	unset MAKEFLAGS

	red=$(tput setaf 1)
	green=$(tput setaf 2)
	reset=$(tput sgr0)
}

restore_origs() {
	find $srcdir -regex '.+\.[0-9]+\.lpmakeorig' | awk '
	{
		origfname = $0;
		gsub("\.[0-9]+\.lpmakeorig$", "");
		fname = $0;
		if (!vers[fname] || vers[fname] > origfname)
			{ vers[fname] = origfname; }
	}
	END { for (f in vers) system("mv " vers[f] " " f); }
'
}

# 负责将 源文件+patch=新的源代码 的新代码替换为补丁之前的代码
# 脚本退出时候会执行这个函数
trap "restore_origs" 0

build_objects() {
	restore_origs
	
	JOBS_MAKE=""
	test $jobs_make && JOBS_MAKE="-j $jobs_make"

	# --clean 清理
	if test -n "$do_clean"; then
		press_any_key "make $LPMAKEFILE clean"
		make $LPMAKEFILE clean >$MAKE_OUTPUT 2>&1
		rm -rf "$LPMAKE_ORIGINAL_DIR" "$LPMAKE_PATCHED_DIR"
	fi

	export KPATCH_STAGE=original
	export KPCC_DBGFILTER_ARGS=""

	# 编译原始 代码 -> make
	echo "${green}BUILDING ORIGINAL CODE${reset}"
	press_any_key "生成原始汇编文件: make $LPMAKEFILE $JOBS_MAKE"
	make $LPMAKEFILE $JOBS_MAKE >$MAKE_OUTPUT 2>&1
	
	# 安装原始 可执行文件 
	# lpmake
	echo "${green}INSTALLING ORIGINAL OBJECTS INTO $LPMAKE_ORIGINAL_DIR${reset}"
	press_any_key "安装原始可执行文件: CC=$CC, make $LPMAKEFILE install $destdir=$LPMAKE_ORIGINAL_DIR"
	make $LPMAKEFILE install				\
		"$destdir=$LPMAKE_ORIGINAL_DIR"			\
		>$MAKE_OUTPUT 2>&1

	local oldpwd="$(pwd)"
	# 字符串长度不为 0
	if test -n "$srcdir"; then
		cd "$srcdir"
	fi

	i=0
	for patch; do
		# applying ../qemu-6.1.0.patch/0002-qemu-img.patch...
		echo "${red}applying $patch...${reset}"
		# -b  make backup file
		# -z
		# -p  
		# 这将 src.c + src.patch = src-patch.c 还原出补丁后的代码
		press_any_key "还原补丁代码: PWD=$PWD, ==> $patch ==> .${i}.lpmakeorig"
		patch -b -z .${i}.lpmakeorig -p1 < $patch
	done
	
	#echo "============================================================="
	if test -n "$srcdir"; then
		cd "$oldpwd"
	fi

	export KPATCH_STAGE=patched
	export KPCC_APPEND_ARGS="-Wl,-q"

	# 编译补丁后 代码
	echo "${green}BUILDING PATCHED CODE${reset}"
	press_any_key "编译补丁代码: CC=$CC, make $LPMAKEFILE $JOBS_MAKE"
	make $LPMAKEFILE $JOBS_MAKE >$MAKE_OUTPUT 2>&1
	press_any_key "上面的步骤生成了 补丁前后及其对比的汇编文件"

	# 将补丁后代码安装到 对应路径
	# .lpmaketmp/patched
	echo "${green}INSTALLING PATCHED OBJECTS INTO $LPMAKE_PATCHED_DIR${reset}"
	press_any_key "安装补丁代码: CC=$CC, make $LPMAKEFILE install $destdir=$LPMAKE_PATCHED_DIR"
	make $LPMAKEFILE install				\
		"$destdir=$LPMAKE_PATCHED_DIR"			\
		>$MAKE_OUTPUT 2>&1
}

build_kpatches() {
	# 创建文件夹 patchroot，用于存放 kpatch 补丁文件
	mkdir -p "${LPMAKE_PATCHROOT}"
	
	echo "${green}MAKING PATCHES${reset}"
	press_any_key "开始制作补丁"

	# 查找 lpmake 目录下有可执行权限的 文件
	for execfile in $(find "$LPMAKE_ORIGINAL_DIR" -perm /0111 -type f); do
		# 可执行文件: 带路径
		origexec="$execfile"
		# 可执行文件: 不带路径
		filename="${origexec##*$LPMAKE_ORIGINAL_DIR/}"
		# 对应的 patch 文件 .lpmaketmp/patched/foo
		# 此 ELF 文件是有 .kpatch section 的
		patchedexec="$LPMAKE_PATCHED_DIR/$filename"
	
		#echo "origexec = $origexec"
		#echo "filename = $filename"
		#echo "patchedexec = $patchedexec"

		# 查找 原始文件中对应的 Build ID
		# 注意：原始 可执行文件 与 kpatch 可执行文件的 Build ID 是不同的
		buildid=$(eu-readelf -n "$origexec" | sed -n '/Build ID:/ { s/.* //; p }')

		press_any_key "获取 $origexec 的 Build ID = $buildid"
		#echo "$origexec Build ID = $buildid"
		# 这个 patch ELF 可执行文件中是否包含 .kpatch section
		# -q: quiet
		if ! eu-readelf -S "$patchedexec" | grep -q '.kpatch'; then
			press_any_key "$patchedexec 中不包含 .kpatch section"
			continue
		fi

		test -n "$buildid" || continue

		press_any_key "$patchedexec 中包含 .kpatch section"

		# 添加可执行权限
		chmod u+w "${origexec}" "${patchedexec}"

		press_any_key "脱去 ${patchedexec} 中除了.kpatch以外的seciton"
		# 脱去没用的 section
		$KPATCH_PATH/kpatch_strip --strip "${patchedexec}" \
			"${patchedexec}.stripped" >/dev/null
		$KPATCH_PATH/kpatch_strip --rel-fixup "$origexec" \
			"${patchedexec}.stripped" || continue
		/usr/bin/strip --strip-unneeded "${patchedexec}.stripped"
		$KPATCH_PATH/kpatch_strip --undo-link "$origexec" "${patchedexec}.stripped"
		# 生成 kpatch 热补丁文件
		press_any_key "生成热补丁文件: ${LPMAKE_PATCHROOT}/${buildid}.kpatch"
		$KPATCH_PATH/kpatch_make -b "$buildid" \
			"${patchedexec}.stripped" -o "${patchedexec}.kpatch"
		cp "${patchedexec}.kpatch" "${LPMAKE_PATCHROOT}"/${buildid}.kpatch
		echo "patch for ${origexec} is in ${LPMAKE_PATCHROOT}/${buildid}.kpatch"
	done
}

main() {
	PROG_NAME=$(basename $0)

	TEMP=$(getopt -o s:ucdj: --long srcdir:,update,clean,destdir: -n ${PROG_NAME} -- "$@" || usage 1)
	eval set -- "$TEMP"

	destdir="DESTDIR"
	while true; do
		case $1 in
		-s|--srcdir)
			shift
			srcdir="$1"
			shift
			;;
		-u|--update)
			shift
			only_update=1
			;;
		-c|--clean)
			shift
			do_clean=1
			;;
		-d|--destdir)
			shift
			destdir=$1
			shift
			;;
		-j|--jobs)
			shift 
			jobs_make=$1
			shift
			;;
		--)
			shift; break;
			;;
		esac
	done

	prepare_env
	
	# 字符串长度为0
	if test -z "$only_update"; then
		build_objects "$@"
	fi
	build_kpatches
}

press_any_key "Ready to start"
main "$@"
